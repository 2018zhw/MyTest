base64的编码是将原来以8bit的二进制转换成6bit的二进制表示，前面高2位用0补，前者是从ASCII表中匹配，后者是从base64位表中匹配
举个例子来说：
　　比如love.png，文件大小是2KB，其实是2×1024byte，也就是2048字节，也就是2048个8位二进制序列，按照ASCII转换的话，
    就是2048个字符，也就是类似SaqeqWEQwQ871...这个的2048个字符。
　　采用base64算法将其转换成base64格式后，这个图片会转换成2048×8/6==2734，即2734个6位二进制序列，
    照Base64表转换的话，就是2048个字符，也就是类psadSaqeqWEQ1231171...这个的2734个字符。
　　聪明的你也许会问？2734个字符比2048个字符多，为什么反而更加快速了呢？
　　抛开别的不谈，我们只谈当前问题本身，从数据库思维去思考，从一张256索引表中查找2048个字符串，
    与从64索引表中查找2734个字符串，哪个成本更低一点，显然256×2048远大于64×2734。
　　也就是说，在一定范围内，base64解析速度更快。

    图片的 base64 编码就是可以将一副图片数据编码成一串字符串，使用该字符串代替图像地址。
　　这样做有什么意义呢？我们知道，我们所看到的网页上的每一个图片，
    都是需要消耗一个 http 请求下载而来的（所有才有了 csssprites 技术的应运而生，
    但是 csssprites 有自身的局限性，下文会提到）。
　　没错，不管如何，图片的下载始终都要向服务器发出请求，要是图片的下载不用向服务器发出请求，
    而可以随着 HTML 的下载同时下载到本地那就太好了，而 base64 正好能解决这个问题。
　　所以，在这里要明确使用 base64 的一个前提，那就是被 base64 编码的图片足够尺寸小
　　使用 Base64 的好处是能够减少一个图片的 HTTP 请求，
   然而，与之同时付出的代价则是 CSS 文件体积的增大（增加大约三分之一，3*8=4*6=24）。
　　Base64 跟 CSS 混在一起，大大增加了浏览器需要解析CSS树的耗时。
    其实解析CSS树的过程是很快的，一般在几十微妙到几毫秒之间。

